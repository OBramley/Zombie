MODULE ham_gpu 


    use mod_types
    use alarrays
    use dnad
    use globvars
    use cudafor
  
    contains

    attributes(global) subroutine overlp_x(z1d, z2d, result)
        type(dual2),dimension(0:2*norb) :: z1d,z2d
        real(wp), intent(inout) :: result

        integer :: j

        ! Calculate the global index for this thread
        j = (blockIdx%x - 1) * blockDim%x + threadIdx%x

        if (j <= norb) then
            result = result*((z1d(j)%x * z2d(j)%x) + (z1d(j+norb)%x * z2d(j+norb)%x))
        end if
    end subroutine overlp_x


    attributes(global) subroutine overlp_dx(z1d, z2d, result)
        type(dual2),dimension(0:2*norb) :: z1d,z2d
        real(wp), dimension(:),intent(inout) :: result

        integer :: j,l

       
        j = (blockIdx%x - 1) * blockDim%x + threadIdx%x
        l = blockIdx.y * blockDim.y + threadIdx.y


        if (j <= norb).and.(l<=norb) then
            if(j.ne.l)then 
                result(j)=result(j)*((z1d(l)%x * z2d(l)%x) + (z1d(l+norb)%x * z2d(l+norb)%x))
            else
                result(j)=result(j)*(z1d(j)%x*z2d(j)%dx(j)+z1d(j)%dx(j)*z2d(j)%x)+&
                        (z1d(j+norb)%x*z2d(norb+j)%dx(j)+z1d(j+norb)%dx(j)*z2d(norb+j)%x)
            end if
        end if

    end subroutine overlp_dx

    attributes(global) subroutine haml_x(z1d, z2d, elecs, result)

        type(dual2),dimension(0:2*norb) :: z1d,z2d
        type(elecintrgl),intent(in)::elecs
        real(wp), dimension(:), intent(inout) :: result

        integer :: j,l

        j = (blockIdx%x - 1) * blockDim%x + threadIdx%x
        l = blockIdx.y * blockDim.y + threadIdx.y

        if (j <= elecs%num).and.(l<=norb) then
            result(j)=result(j)*(z1d(l)%x*elecs%neg_a(l,j)*z2d(elecs%alive(l,j))%x+&
            z1d(l+norb)%x*elecs%neg_d(l,j)*z2d(elecs%dead(l,j))%x)
        end if 
    end subroutine haml_x

    attributes(global) subroutine haml_dx(z1d, z2d, elecs, result)

        type(dual2),dimension(0:2*norb) :: z1d,z2d
        type(elecintrgl),intent(in)::elecs
        real(wp), dimension(:,:), intent(inout) :: result

        j = (blockIdx%x - 1) * blockDim%x + threadIdx%x
        l = blockIdx.y * blockDim.y + threadIdx.y
        k = blockIdx.z * blockDim.z + threadIdx.z

        if((j <= elecs%num).and.(l<=norb) .and.(k<=norb))then
            if(l.ne.k)then
                result(j,l)=result(j,l)*(z1d(k)%x*elecs%neg_a(k,j)*z2d(elecs%alive(k,j))%x+&
                z1d(k+norb)%x*elecs%neg_d(k,j)*z2d(elecs%dead(k,j))%x)  
            else
                result(j,l)=result(j,l)*((z1d(k)%x*elecs%neg_a(k,j)*z2d(elecs%alive(k,j))%dx(l)+&
                    z1d(k)%dx(l)*elecs%neg_a(k,j)*z2d(elecs%alive(k,j))%x)+&
                    (z1d(k+norb)%x*elecs%neg_d(k,j)*z2d(elecs%dead(k,j))%dx(l)+&
                    z1d(k+norb)%dx(l)*elecs%neg_d(k,j)*z2d(elecs%dead(k,j))%x))
            end if 
        end if

    end subroutine haml_dx